
一、接口协议约定
=================

1、所有接口提交或返回的数据以JSON格式传输。

2、所有参数名称及加密后字符（包含签名），默认使用小写，除非有特别约定的地方会有特殊说明。

3、请求数据格式如下：
  {
    "company_name": "abcdef",
    "code_name": "001",
    "short_name": "a",
  }

4、有些接口需要客户端对数据进行加密，其请求数据格式如下：
  1) JSON（application/json）:
    {
      "encrypted_data": "U2FsdGVkX18y5aFF83lg4Mc8+AMZNoVXYQ9dSB+YP5ld2RIRJkoU35f/4owrSelE+1j8AzR3vKESchs+/pYnqHI7h4U0nWM90LSlZ+wqeEI=",
      "timestamp": 1542872055207,
      "sign": "U2FsdGVkX18y5a"
    }
  2) 表单（application/x-www-form-urlencoded）方式提交：
    encrypted_data=U2FsdGVkX18y5aFF83lg4Mc8+AMZNoVXYQ9dSB+YP5ld2RIRJkoU35f/4owrSelE+1j8AzR3vKESchs+/pYnqHI7h4U0nWM90LSlZ+wqeEI=&sign=U2FsdGVkX18y5a&timestamp=1542872055207
 
  3) 采用URL查询参数，要注意用`encodeURIComponent`将加密的内容编一下码：
    encrypted_data=U2FsdGVkX18y5aFF83lg4Mc8%2BAMZNoVXYQ9dSB%2BYP5ld2RIRJkoU35f%2F4owrSelE%2B1j8AzR3vKESchs%2B%2FpYnqHI7h4U0nWM90LSlZ%2BwqeEI%3D&sign=U2FsdGVkX18y5a&timestamp=1542872055207

  * 加密规则：
  1) 数据加密使用 AES。
  2) AES 算法（256，ECB，补码方式：PKCS5Padding）。
  3) AES 密文使用 base64 编码
  4) 数据加密密钥为 appkey
  5) 加密内容为整个要提交的JSON内容。
  6) 加密内容使用固定的属性名：`encrypted_data`。

5、有些接口会对返回来的数据进行加密，加密规则如上，客户端可以按上面的规则进行解密，其返回的数据格式如下：
  1) JSON（application/json）:
    {
      "encrypted_data": "U2FsdGVkX18y5aFF83lg4Mc8+AMZNoVXYQ9dSB+YP5ld2RIRJkoU35f/4owrSelE+1j8AzR3vKESchs+/pYnqHI7h4U0nWM90LSlZ+wqeEI="
    }
  2) 其它格式，直接返回加密内容：
    U2FsdGVkX18y5aFF83lg4Mc8+AMZNoVXYQ9dSB+YP5ld2RIRJkoU35f/4owrSelE+1j8AzR3vKESchs+/pYnqHI7h4U0nWM90LSlZ+wqeEI=

6、所有请求（包含GET、POST、DELETE、PUT等）都要设置access_token参数，可以使用以下三种方式设置：
   1) 放在Header的认证头里（推荐这种方式）：
        Authorization: 'Bearer '+ access_token
   2) 直接放在Header头里：
        X-Token: access_token
   3) 放在URL查询参数里：
        token=access_token

7、所有的 POST、PUT、PATCH 请求都必须带签名，签名可以使用以下三种方式携带
  1) 放到Header头里传递： 
      X-Sign: 6KGo5Y2V5oiWVVJM5p+l6K+i5Y+C5pWw
      X-timestamp: 1542872055207
  2) 表单（application/x-www-form-urlencoded）方式提交：
      data=xxx&sign=6KGo5Y2V5oiWVVJM5p+l6K+i5Y+C5pWw&timestamp=1542872055207
  3) 采用URL查询参数，要注意用`encodeURIComponent`将签名的内容编一下码：
      data=xxx&sign=6KGo5Y2V5oiWVVJM5p%2Bl6K%2Bi5Y%2BC5pWw&timestamp=1542872055207
  4) 如果提交内容是JSON格式，可以将签名参数放到JSON中：
      {
        "data": "6KGo5Y2V5oiWVVJM5p+l6K+i5Y+C5pWw",
        "timestamp": 1542872055207,
        "sign": "6KGo5Y2V5oiWVVJM5p+l6K+i5Y+C5pWw"
      }

  * 签名规则：
  1) 把所有参数的key 按 ascii 码 a-z 排序
  2) 把排序后的参数(key=value)用&拼接起来，如：code_name=001&company_name=abcdef&short_name=a
  3) 签名密钥使用 appkey
  4) 使用 HMAC-SHA1 加密算法，使用 Step3 中得到的密钥对 Step2 中得到的源串加密
  5) 然后将加密后的字符串经过 Base64 编码
  6) 最后将得到的签名值，放到 Header 头里
  7) 如果提交内容是JSON格式，在生成签名内容时，子对象要用大括号`{}`括起来，数组用逗号`,`分隔，比如：
      提交内容是：
        {
            "code": 0,
            "data": {
                "access_token": "glqrpmoYp1YsK9FMbkV",
                "app_id": 28378403702864386,
                "expires_in": 1440,
                "refresh_token": "nzyfdM8UJrpsXk2QtMx",
                "scope": [
                    "user",
                    "photo"
                ]
            },
            "msg": "成功"
        }
      签名的内容是：
        code=0&data={access_token=glqrpmoYp1YsK9FMbkV&app_id=28378403702864386&expires_in=1440&refresh_token=nzyfdM8UJrpsXk2QtMx&scope=user,photo&msg=成功
  8) 如果同时有提交内容和URL查询参数时，在计算签名时，要将两边的内容都计算在内。
  9) 最后要注意：如果需要对提交的数据加密，请加密后，再签名。

8、所有返回的内容都要签，签名规则如上，客户端可以按上面的规则验证签名，签名放到Header头里返回。

9、其它要放到Header头的信息有：
  * Call-Source 调用来源(IOS、ANDROID、PC、WECHAT、WEB)
  * Api-Version api的版本号
  * App-Version app版本号(当 Call-Source 为 IOS、ANDROID 时，为必填项)

10、成功时返回的数据格式：
    {
        "code": 0,
        "data": {
            "list": [
                {
                    "company": {
                        "codeName": "01043",
                        "companyName": "宜兴华胜汽车服务有限公司",
                        "disabled": true,
                        "id": "COM20120312000002",
                        "shortName": "无锡宜兴店",
                    },
                    "companyId": "COM20120312000002",
                    "deptName": "维修部",
                    "dutyName": "钣金组长",
                    "disabled": true,
                    "id": "MEM20141204000006",
                    "loginId": "",
                    "userName": "顾方清"
                },
                {
                    "company": {
                        "codeName": "01006",
                        "companyName": "苏州华策汽车维修服务有限公司",
                        "disabled": true,
                        "id": "COM20100211000007",
                        "shortName": "苏州吴中店",
                    },
                    "companyId": "COM20100211000007",
                    "deptName": "维修部",
                    "dutyName": "喷漆组长",
                    "disabled": true,
                    "id": "MEM20141204000021",
                    "loginId": "",
                    "userName": "张庆飞"
                }
            ],
            "page": 300,
            "pageSize": 5,
            "pages": 400,
            "size": 5,
            "total": 2000
        },
        "msg": "成功"
    }
  其中：code、msg 是公共参数，每次返回都会有

11、失败时返回的数据格式：
  {
      "code": 10001,
      "msg": "参数无效",
      "data": [
          {
              "fieldName": "status",
              "message": "值是无效的"
          }
      ]
  }

二、Nginx
=================

1、在使用nginx做反向代理时，要记录整个的代理过程，要在请求里面放入 X-Forwarded-For，X-Real-IP 两个头信息，
   这样在内部服务器中，才能获取到客户端的真实IP，

2、在nginx 配置文件中增加如下配置即可：
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

  * 注意：如果有多级代理，只在第一级代理设置 X-Real-IP


三、网关服务：
=================
1、验证 access_token

2、验证签名

3、统一加密、解密（针对指定接口）

4、将请求转发到内部服务时，需添加以下内容到头信息中：
  * 访问用户的ID 
      X-User: userId
      X-Auth-User: base64(user)
  * 访问令牌：
      X-Token: access token
      X-Auth-Token: base64(token)

四、认证服务
=================
1、

五、业务服务
=================

1、基础参数的校验
   * Controller层使用 Validator 校验
   * Service 层使用 Assert 校验

2、统一的响应格式，详见《一、接口协议约定》的第8、9两条约定。

3、全局的异常捕获：

  * 统一所有的异常返回码：
  1) code = 0: 正确返回
  2) code > 0: 调用OpenAPI时发生错误，需要开发者进行相应的处理。
  3) -50 <= code <= -1: 接口调用不能通过接口代理机校验，需要开发者进行相应的处理。
  4) code <-50: 系统内部错误，请联系技术支持，调查问题原因并获得解决方案。 

  * 要根据不同的异常返回合适的 HTTP 状态码

  * 对于系统的错误，一定要详细的打印好日志，要将异常的详细堆栈上下文信息都打印出来（不能只打印e.getMessage），方便线上排查问题

4、请求参数、响应结果日志打印：
  * 从网关开始，对每次请求的完整调用链能打印出。

  * 目前打印的主要信息有：
     请求者、请求的类.方法名字、请求的参数（参数敏感信息需要用 “**”替换）、请求者IP、调用源、App版本号、Api版本号、
     客户端的userAgent信息、响应的结果（敏感词过滤）、最后请求结束后所花费的时间。


Redis:
================================
1.查看所有key值：keys *

2.删除指定索引的值：del key

3.清空整个 Redis 服务器的数据：flushall 

4.清空当前库中的所有 key：flushdb 


[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'information_schema.PROFILING.SEQ' 
  which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

SELECT @@GLOBAL.sql_mode;

set GLOBAL sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';



mvn flyway:migrate
mvn flyway:info
mvn flyway:clean



<build>
    <plugins>
        <plugin>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-maven-plugin</artifactId>
            <configuration>
                <url><![CDATA[jdbc:mysql://192.168.111.119:3306/hscp_id_db?useUnicode=true&characterEncoding=UTF-8&useSSL=false]]></url>
                <user>root</user>
                <password>123456</password>
            </configuration>
        </plugin>
    </plugins>
</build>




1. 要提交的JSON对象
var jsonobj = {
  "name": "sky",
  "id": 1233
}

2. 将JSON对象转成字符串
var jsonstr = JSON.toString(jsonobj);

3. 如果要加密，则调用AES的加密函数，如果不要加密，则跳到 setp5.2
var encryptstr = AES.encrypt(jsonstr);

4. 生成新的要提交的对象，
var jsonobj_new = {
  "encrypted_data":  encryptstr
}

5. 获取签名内容

5.1 如果内容加密：
var signstr = SIGN_CONTENT(jsonobj_new);　　==>　encrypted_data＝encryptstr

5.2 如果内容不加密：
var signstr = SIGN_CONTENT(jsonobj);　　==> name=sky&id=1233

6. 生成签名
var sign = SIGN(signstr);
var timesnamp = new Date().getTime();

7. 最终要提交的JSON对象
var jsonobj_final = {
  "encrypted_data":  encryptstr，
  "sign": sign,
  "timesnamp":　timesnamp
}




